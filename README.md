#### 一、面向对象设计原则



##### 1、依赖倒置原则（DIP）

```
a. 高层模块(稳定)不应该依赖于低层模块(变化),二者都应该依赖于抽象(稳定)

b.抽象(稳定)不应该依赖于实现细节(变化的),实现细节应该依赖于抽象(稳定)。

   上面意思就是说，高层和底层模块都不相互依赖，而是依赖抽象。而且抽象不依赖抽象具体实现细节。如果抽象依赖了实现细节 那么在修改实现细节代码时，抽象也要跟着改变，这样就违背了该原则。


Tips:依赖倒置原则几乎贯穿于所有的设计模式。学习设计模式我们应该深刻理解其设计原则。 所有的设计都是依赖设计原则推导出来的。如果它违背了设计原则那么这个设计模式就是错误的。 不同的设计模式千差万别但是表示的同一个意思。
```



##### 2、开放封闭原则(OCP)

```
 a、对扩展开放,对更改封闭。

 b、类模块应该时可扩展的,但是不可修改。
```

##### 3、单一职责原则(SRP)

```
  a、一个类应该仅有一个引起它变化的原因。

  b、变化的方向隐含着类的责任。
```

##### 4、LisKov 替换原则(LSP)

```
 a、子类必须能够替换它们的基类(IS-A)

 b、继承表达类型抽象
```

##### 5、接口隔离原则(ISP)

```
 a、不应该强迫客户程序依赖他们不用的方法。

 b、接口应该小而完备。
```

##### 6、优先使用对象组合,而不是类继承

```
 a、类继承通常为"白箱复用"，对象组合通常为"黑箱复用"

 b、继承在某种程度上破坏了封装性，子类父类耦合度高。

 c、而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。
```



##### 7、封装变化点

```
 a、使用封装来创建对象之间的分界层,让设计者可以在分界的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次件的松耦合。
```



##### 8、针对接口编程,而不是针对实现编程

```
 a、不将变量类型声明为某个特定的具体类,而是声明为某个接口。

 b、客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。

 c、减少系统中各部分的依赖关系，从而实现"高内聚、松耦合"的类型设计方案。
```



```
重构获得模式 Refactoring to Patterns
a、面向对象设计模式是"好的面向对象设计"， 所谓"好的面向对象设计" 指的是那些可以满足 "应对变化，提高复用"的设计。
b、现代软件设计的特征是"需求的频繁变化"。设计模式的要点是"寻找变化点",然后在变化点处应用设计模式，从而来更好的应对需求的变化"。"什么时候、什么地点应用设计模式" 比 "理解设计模式结构本身"更为重要。
c、设计模的应用不易先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。
敏捷软件开始实践提倡的"Refactoring to Patterns" 是目前普遍公认的最好的使用设计模式的方法。
```

```
重构关键技法
静态----动态
早绑定---晚帮定
继承---组合
编译时依赖---运行时依赖
紧耦合----松耦合

```

```
"组件协作"模式:
现在软件专业分工之后的第一个结果是"框架与应用程序的划分"，"组件协作"模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。

```



#### 二、学习设计模式的方法

##### 1、在学习设计模式时 应该带着问题去思考。

比如 如果没有在写代码的时候，如果不使用设计模会怎么样？ 如果使用了设计模式优会怎么样？ 还有就是将这个代码放在时间轴里去思考。在一段时间内是否会改变？

##### 2、设计模式的真谛

是在编译时复用，在运行时产生不一样的。它的变化都放在运行时用多态的来支持它的变化。



#### 三、重新认识面向对象

```
1、理解隔离变化
  从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小

2、各司其职
  从微观层面来看，面向对象的方式更强调各个类的"责任"
  由于需求变化导致的新增类型不应该影响原来类型的实现----是所谓各负其责
3、对象是什么
  从语言实现层面来看，对象封装了代码和数据。
  从规格层面讲，对象是一系列可被使用的公共接口。
  从概念层面讲，对象是某种拥有责任的抽象。

```



##### 四、模式的分类

```
"组件协作"模式:
 .Template Method
 .Strategy
 .Observer/Event

单一职责:
 .Decorator
 .Bridge

对象创建:
 .Factory Method
 .Abstract Factory
 .Prototype
 .Builder
 

对象性能:
 .Singleton
 .Flyweight 

接口隔离:
 .Facade
 .Proxy
 .Mediator
 .Adapter
 
状态变化:
 .Memento
 .State 

数据结构:
 .Composite
 .Iterator
 .Chain of
 .Resposibility

行为变化:
 .Command
 .Vistor

领域问题:
 .Interpreter
 
 



```

